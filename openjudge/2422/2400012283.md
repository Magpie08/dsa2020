
# 问题的分析
    小白解读大法：
        第一步：要将字母转化为二进制数
            *含空格的转化、5位二进制数
        第二步：顺时针补充矩阵
            *剩余空位填0
        第三步：顺序输出
# 对解题方法的说明
    并没有很高深巧妙的解法，采用了非常实际的设身处地思考法
    在第二步填充矩阵的时候，从左上角出发，模拟填充数据的过程，在什么条件下要“转弯

# 对程序结构的分析
    1.定义 jiema(c)函数，对每个元素进行5位二进制转化
    2. 定义 matr(r,c,ming)函数，开始填充矩阵，并得到顺序输出的结果：
        首先，为了省去在最后补填0的步骤，直接建立一个全是0的矩阵
        然后，在这界定了上、下、左、右四个边界，按照从左上角右下左上的顺序走，每走到一个边界就“转弯”
        为了确定在每往后走一步，矩阵里要填的是密码中的第几位，引入变量num
        且为了避免越界，在密码填完的情况下还要从中读取（会报错），用while来设置条件
        
        以第一个for循环为例子（从左往右）：
            从左边界，到右边界，只选一行填写
            用if函数确保不会越界后在填写，将本行第i个数（从0开始）改为对应的密码二进制
            填完这一位，下一次要填就是密码下一位，所以num要+1
            等一整行都填写完，即本行可以理解为隐藏了，新的上边界就变成top+1
            螺旋到最后top会和bottom到一行，如果再往下走，top就会变成新的下界（且此时矩阵已填完）
            所以用if确定结束条件，如果top>bottom，就结束从左到右的填写

            其他方向类似
            四种方向的顺序按真正模拟的顺序走

            最后顺序输出即可
    3.处理输入：
            因为要解码的密码里可能有空格，如果直接split，会把密码也分掉
            我这里把前两个空格换成*，在用*为依据分开输入

# 解题感想
    本身并不是特别会写代码，所以并没有去向精明或者简洁的代码，只是采用了自己简单直白的思路，并分享出来。
# 踩过的坑
    代码里就有体现，一开始没有检查越界，导致error了好几次
    以及，边界的移动是在一整行/列填完，所以不在for循环里
    再以及，不是坑，只是一个小盲点（？，密码里有可能有连着的许多空格，如果一开始直接split就全没了！后面再连上也于事无补